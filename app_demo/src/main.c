#include "appinc.h"
#include <signal.h>

void sigHandle(int sig)
{
    switch (sig) {
    case SIGINT:
		OsLog(LOG_ERROR,"*** catch signal : SIGINT, value = %d\n", sig);
        break;
    case SIGTERM:
		OsLog(LOG_ERROR,"*** catch signal : SIGTERM, value = %d\n", sig);
        break;
    case SIGBUS:
		OsLog(LOG_ERROR,"*** catch signal : SIGBUS, value = %d\n", sig);
        break;
    case SIGSEGV:
		OsLog(LOG_ERROR,"*** catch signal : SIGSEGV, value = %d\n", sig);
        break;
    case SIGFPE:
		OsLog(LOG_ERROR,"*** catch signal : SIGFPE, value = %d\n", sig);
        break;
    case SIGABRT:
		OsLog(LOG_ERROR,"*** catch signal : SIGABRT, value = %d\n", sig);
        break;
    case SIGSTOP:
		OsLog(LOG_ERROR,"*** catch signal : SIGSTOP, value = %d\n", sig);
        break;
    default:
		OsLog(LOG_ERROR,"*** catch unknown signal, value = %d\n", sig);
        break;
    }
    exit(0);
}

void signalHandle(){
    signal(SIGPIPE, sigHandle);	// Ignore the signal
    signal(SIGINT, sigHandle);  //Ctrl + C
    signal(SIGTERM, sigHandle); // Software termination issued by kill
    signal(SIGBUS, sigHandle);  // Bus error
    signal(SIGSEGV, sigHandle); // Illegal memory access
    signal(SIGFPE, sigHandle);  // Math-related exceptions, such as division by zero, floating-point overflow, etc.
    signal(SIGABRT, sigHandle); // Generated by calling the abort function, the process exits abnormally
    signal(0x108, sigHandle);
    signal(0x107, sigHandle);
    // signal(SIGSTOP, sigHandle); // Generated by calling the abort function, the process exits abnormally
}

extern int ymframwork_init(int argc, char *argv[]);
extern int ymframwork_finish(int ret);
extern void lvgl_main(void);

void lvgl_disp_pause(int runstate, void *par)
{
    disp_disable_update();
}
void lvgl_disp_resume(int runstate, void *par)
{
    disp_enable_update();
}

void DisplayInit(){
    Disp_vInit(); //UI  init
    Disp_vSetStatusBarStatus(0);
    Disp_vRegisterPauseCallBack(lvgl_disp_pause);
    Disp_vRegisterResumeCallBack(lvgl_disp_resume);
}

int App_nInitialization()
{
    char szAppId[] = "linux_app";
    OsLogSetTag(szAppId);  //set logcat tag
    signalHandle();
    Disp_vSetStatusBarStatus(0);
	DisplayInit();   //UI init
    DB_bInit(szAppId); //database init
    EmvL2_Init();   // EMV initialization
    //EmvL2_SetDefaultAidAndCapk();

	return 0;
}

#include "memtrack.h"

void test_function(void) {
    // This will leak memory.
    char* leak = trackmalloc(100);
    sprintf(leak, "This memory will be leaked");
    
    // This will not leak memory.
    char* no_leak = trackmalloc(50);
    sprintf(no_leak, "This memory will be freed");
    trackfree(no_leak);
}

void test()
{
    memtrack_init();

    int* array = trackmalloc(10 * sizeof(int));
    for (int i = 0; i < 10; i++) {
        array[i] = i * 10;
    }
    test_function();
    trackfree(array);

    memtrack_cleanup();
}

int main(int argc, char *argv[])
{
    int ret;
    ymframwork_init(argc, argv);//system api
    App_nInitialization();
    lvgl_main();
    Disp_vSetStatusBarStatus(1);
    ymframwork_finish(ret);//system api
    return 0;
}